________________________________

  Wed Jan  2 23:36:37 CET 2018
________________________________

  Look up ski shit (prices at local bodega, ski slope)
  debugging.py





































































________________________________

  Mon Dec 31 23:36:37 CET 2018
________________________________

  Refactor all code so definitions of functions aren't obstructing clear, easy reading of code.
    (no definitions of functions within functions)



































________________________________

  Sun Dec 30 23:36:37 CET 2018
________________________________

  sort .py files into more dirs so ls -ltrAh has reasonable (not too many) results





































________________________________

  Tue Dec 25 20:07:22 EST 2018
________________________________

  Get marching_cubes() working so we can visualize mesh
    Done.
  Amazon checkout
    What did I mean by this?
  git recover the full skinning function (checks each of the adjacent voxels for "on" status and decides "on" or "off" based on this)

  compare skin with full model (perhaps it's not wrong to have a straight line at parts of the body)
































    fix rot8() func to deal with out-of-bounds voxels after rotation 
      DONE?  (test this)
________________________________

  Sun Dec 23 20:07:22 EST 2018
________________________________

  Debug:
    (cat_opencv3)  how come this rotates stuff off the "screen"?   I don't really understand why it has to get wiped out this way............'
    We have to do the rotation s.t. it initially expands the possible locs before cutting off any out-of-bounds voxels.  Perhaps the best way to do this is to do the rotation, remove those "external" points, then do all the rounding and "model[idxes]=True"-setting

    lookup hollow() or get_skin() in numpy/scipy/rawPython




































































________________________________

  Fri Dec 21 20:07:22 EST 2018
________________________________

  Idea:
    Rotate bunch of voxel coordinates using simple 3x3 rotation matrix, then make a 2x2x2 block around each of the new voxel locations and turn those 8 voxels "on" in the rotated np array.
      Here the limiting step is conversion btwn data forms.
      Wait, how did I fucking not think of this before?  It's so beautifully simple.
      Is this faster than the other way of going through space voxel by voxel, doing the inverse rotation, and then checking whether the voxel nearest the inverse rotated point is on?
        Potentially, because this way we're only dealing with the locs that are "on"
        I could dream up an optimization where we constantly keep a running "checklist" of the voxels that are "on" (in a hashtable) and remove things whenever the corresponding rotated pt is turned "off" by a masking.  This way we don't have to convert as much; just have to make sure we do the angle math right
        The reason this is faster is I can use ANY previously optimized matrix-processing code to do this rotation; it's just a single matrix multiplication.  Hrm...

  Idea 2:  scipy.ndimage.rotate() and fill in the gaps

  numpy notes:
    /home/u/Documents/code/numpy_notes/notes.py
  Technical:
    Speed up rotation.  Probably best advices is to profile, then always remove for-loops






























________________________________

  Fri Dec 14 17:29:40 EST 2018
________________________________

Technical:
  Mask right.
  /home/u/Documents/code/debuggig_scipy_rotate
    put headers in SO question to make it easier to read

  Idea:
    Rotate bunch of voxel coordinates using simple 3x3 rotation matrix, then make a 2x2x2 block around each of the new voxel locations and turn those 8 voxels "on" in the rotated np array.
      Here the limiting step is conversion btwn data forms.
      Wait, how did I fucking not think of this before?  It's so beautifully simple.
      Is this faster than the other way of going through space voxel by voxel, doing the inverse rotation, and then checking whether the voxel nearest the inverse rotated point is on?
        Potentially, because this way we're only dealing with the locs that are "on"
        I could dream up an optimization where we constantly keep a running "checklist" of the voxels that are "on" (in a hashtable) and remove things whenever the corresponding rotated pt is turned "off" by a masking.  This way we don't have to convert as much; just have to make sure we do the angle math right
        The reason this is faster is I can use ANY previously optimized matrix-processing code to do this rotation; it's just a single matrix multiplication.  Hrm...

  Try ndimage.rotate() on basic 3-d model
    https://stackoverflow.com/questions/47197748/rotate-with-scipy-without-interpolation
  Use floats/ints instead of bools!  Convert back to bool later!
    Tried, fixes the problem of holes INSIDE the mask, but generates lots of +noise (1s where there oughta be 0s) OUTSIDE the mask
  Ask on StackOverflow
    better, faster version of ndimage.rotate()
  Use cat_opencv3

  numpy notes:
    /home/u/Documents/code/numpy_notes/notes.py
Biz:































________________________________

  Wed Dec 12 17:29:40 EST 2018
________________________________

Technical:
  Fix pad func (it really breaks shit currently)
  I think it's actually the ndimage.rotate() func that's fucking the shit up, not the pad_both()
    https://stackoverflow.com/questions/47197748/rotate-with-scipy-without-interpolation
  use cat_opencv3
Biz:
  Start scanning
