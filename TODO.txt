________________________________

  Mon Jan 14 12:04:57 EST 2019
________________________________

  1st make perfect (best possible) skin_nathan.npy
    Standardize alignment of the masks (ie. all to the belly button)
    Or weight the "downshift" of the masks by the length across of the widest mask (ie. if we have the full Jesus cross-section, take the length from fingertip to fingertip and that indicates we're looking at the person face-on)
      Whereas if the current length-across of the masks is small (side view), that means the CoM should be bumped up to match the CoM at the Jesus-view (front)
    Or at least CoM-adjustment for masking
  masking











































________________________________

  Thu Jan 10 12:40:46 EST 2019
________________________________

  Vince
    Say "Does Joe Scott need any help on other days?"

    Say "I'm looking for some more responsibility around here.  I've learned how to teach more efficiently and clearly."
      Ask for raise.
        Read up on how to negotiate for this
    Pop by on your off-day
 

  Startup job apps






























  Pay the rent to Jeannine





  Test normals from Voro Poles
    Look @ Desbrun's algo link

    Either with a super-simple normals-to-mesh() algo or
      with unit-tests
    I'm a fan of the prior (mesh is much easier to look at and analyze what's wrong than just the numbers without the associated location information)








  Test the norms on actual skin_nathan_.npy and time it (profile)
    DONE
    real  0m54.368s
    user  0m53.714s
    sys   0m0.844s































  Voro Poles
    BANG, done.  (first iteration)
  Kill Lemonade insurance, Sierra Club subscription (I called Sierra)
    BANG, done








________________________________

  Wed Jan  9 15:09:36 EST 2019
________________________________


  Technical:
    Figure out why ComplexWarning is being thrown
      Step-by-step



































































________________________________

  Wed Jan  2 23:36:37 CET 2018
________________________________

  Look up ski shit (prices at local bodega, ski slope)
  debugging.py





































































________________________________

  Mon Dec 31 23:36:37 CET 2018
________________________________

  Refactor all code so definitions of functions aren't obstructing clear, easy reading of code.
    (no definitions of functions within functions)



































________________________________

  Sun Dec 30 23:36:37 CET 2018
________________________________

  sort .py files into more dirs so ls -ltrAh has reasonable (not too many) results





































________________________________

  Tue Dec 25 20:07:22 EST 2018
________________________________

  Get marching_cubes() working so we can visualize mesh
    Done.
  Amazon checkout
    What did I mean by this?
  git recover the full skinning function (checks each of the adjacent voxels for "on" status and decides "on" or "off" based on this)

  compare skin with full model (perhaps it's not wrong to have a straight line at parts of the body)
































    fix rot8() func to deal with out-of-bounds voxels after rotation 
      DONE?  (test this)
________________________________

  Sun Dec 23 20:07:22 EST 2018
________________________________

  Debug:
    (cat_opencv3)  how come this rotates stuff off the "screen"?   I don't really understand why it has to get wiped out this way............'
    We have to do the rotation s.t. it initially expands the possible locs before cutting off any out-of-bounds voxels.  Perhaps the best way to do this is to do the rotation, remove those "external" points, then do all the rounding and "model[idxes]=True"-setting

    lookup hollow() or get_skin() in numpy/scipy/rawPython




































































________________________________

  Fri Dec 21 20:07:22 EST 2018
________________________________

  Idea:
    Rotate bunch of voxel coordinates using simple 3x3 rotation matrix, then make a 2x2x2 block around each of the new voxel locations and turn those 8 voxels "on" in the rotated np array.
      Here the limiting step is conversion btwn data forms.
      Wait, how did I fucking not think of this before?  It's so beautifully simple.
      Is this faster than the other way of going through space voxel by voxel, doing the inverse rotation, and then checking whether the voxel nearest the inverse rotated point is on?
        Potentially, because this way we're only dealing with the locs that are "on"
        I could dream up an optimization where we constantly keep a running "checklist" of the voxels that are "on" (in a hashtable) and remove things whenever the corresponding rotated pt is turned "off" by a masking.  This way we don't have to convert as much; just have to make sure we do the angle math right
        The reason this is faster is I can use ANY previously optimized matrix-processing code to do this rotation; it's just a single matrix multiplication.  Hrm...

  Idea 2:  scipy.ndimage.rotate() and fill in the gaps

  numpy notes:
    /home/u/Documents/code/numpy_notes/notes.py
  Technical:
    Speed up rotation.  Probably best advices is to profile, then always remove for-loops






























________________________________

  Fri Dec 14 17:29:40 EST 2018
________________________________

Technical:
  Mask right.
  /home/u/Documents/code/debuggig_scipy_rotate
    put headers in SO question to make it easier to read

  Idea:
    Rotate bunch of voxel coordinates using simple 3x3 rotation matrix, then make a 2x2x2 block around each of the new voxel locations and turn those 8 voxels "on" in the rotated np array.
      Here the limiting step is conversion btwn data forms.
      Wait, how did I fucking not think of this before?  It's so beautifully simple.
      Is this faster than the other way of going through space voxel by voxel, doing the inverse rotation, and then checking whether the voxel nearest the inverse rotated point is on?
        Potentially, because this way we're only dealing with the locs that are "on"
        I could dream up an optimization where we constantly keep a running "checklist" of the voxels that are "on" (in a hashtable) and remove things whenever the corresponding rotated pt is turned "off" by a masking.  This way we don't have to convert as much; just have to make sure we do the angle math right
        The reason this is faster is I can use ANY previously optimized matrix-processing code to do this rotation; it's just a single matrix multiplication.  Hrm...

  Try ndimage.rotate() on basic 3-d model
    https://stackoverflow.com/questions/47197748/rotate-with-scipy-without-interpolation
  Use floats/ints instead of bools!  Convert back to bool later!
    Tried, fixes the problem of holes INSIDE the mask, but generates lots of +noise (1s where there oughta be 0s) OUTSIDE the mask
  Ask on StackOverflow
    better, faster version of ndimage.rotate()
  Use cat_opencv3

  numpy notes:
    /home/u/Documents/code/numpy_notes/notes.py
Biz:































________________________________

  Wed Dec 12 17:29:40 EST 2018
________________________________

Technical:
  Fix pad func (it really breaks shit currently)
  I think it's actually the ndimage.rotate() func that's fucking the shit up, not the pad_both()
    https://stackoverflow.com/questions/47197748/rotate-with-scipy-without-interpolation
  use cat_opencv3
Biz:
  Start scanning
  Something funny / fun is better than serious (serious == cringe-worthy)
    ie. doohickey.com
        thingamajig.com
        kitty.com
    Evidence:
      Lemonade's fun voicemail msg
      Virgin America
  Godaddy.com
    tells you domain prices
    seth@godaddy.com : buy a domain name
      Any good domain name is usually at least $10,000

